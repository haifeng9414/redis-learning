redis的字符串底层实现的数据类型叫SDS（simple dynamic string），redis中执行`set msg "hello world"`时，则键值对中的key是一个SDS对象，保存着`msg`，键值对的值也是一个SDS对象，保存着`hello world`。而如果使用的是`rpush`命令，如`rpush fruits "apple" "banana" "cherry"`，则键值对的值为列表对象，列表对象中包含了三个SDS对象。另外SDS对象也会被用于AOF中的缓冲区、客户端状态的缓存区，所以SDS可以认为是redis中字符串实现。

一个SDS的定义：
```c
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];
};
```

SDS遵循C字符串以空字符结尾的惯例，保存空字符的一个字节空间不计算在SDS的len属性里面，这样SDS就可以直接重用一部分C字符串函数库里面的函数。

使用SDS而不是直接使用C字符串的好处：
- 可以以O(1)的时间复杂度获得字符串的长度
- 杜绝了缓冲区溢出的问题，如C语言中执行字符串拼接：`char* strcat(char *dest, const char *src);`，由于C字符串不记录自身的长度，如果用户在执行strcat函数时，没有给dest分配足够的内容来容纳src，就会产生缓冲区溢出（可能会导致dest字符串内存位置之后的其他数据被覆盖）。SDS的空间分配策略，能够完全杜绝缓冲区溢出的发生：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改的需求，若不满足，则API会自动将SDS的空间扩展以至于能够放下src。
- 减少修改字符串时导致的内存重分配次数，C字符串不记录自身的长度，通过最后一个空字符'\0'来表示字符串结束。所以每次拉长或缩短C字符串，程序总要对保存这个C字符串的数组进行一次内存重分配。为了避免C字符串的这种缺陷，redis通过未使用空间来解除字符串长度和底层数组长度之间的关联。在SDS中，buf数组的长度不一定就是字符数量 + 1，buf数组可以包含未使用的字节，这些未使用的字节数量就是free的值。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略：
  - 空间预分配：当API对一个SDS进行修改，并且需要对SDS空间进行扩展，程序不仅会为SDS分配修改所必须的空间，还会额外分配“未使用空间”，通过额外分配空间，减少了连续执行字符串增长操作所需的内存重分配次数，额外分配策略有2种：
    - 如果对SDS进行修改之后，len小于1MB，那么程序分配和len一样大小的未使用空间
    - 如果对SDS进行修改之后，len大于1MB，那么程序分配1MB的未使用空间
  - 惰性空间释放：当需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性来将这些字节记录起来，供将来扩展使用。SDS同时也提供了API，能够在需要的时候释放SDS的未使用空间。
- 二进制安全，C字符串存在二进制安全的问题，只能保存文本数据，而不能保存像图片、音频、视频压缩文件等二进制数据，因为这些类型的数据可能会包含'\0'，而C字符串遇到'\0'就认为是结束了。而SDS的API都是二进制安全的，所有API以处理二进制的方式来处理SDS存放的buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者转义，数据在写入时是怎么样的，被读取时就是什么样。这也是将SDS的buf数组叫做字节数组的原因，Redis不是用这个数组来保存字符，而使用它来直接保存二进制数据，数据的长度通过len属性决定。  